Promises [TODO] {#promises}
--------------------

### Was sind Promises

Promises sind




### Wofür werden Promises eingesetzt

Nehmen wir an, ein Vorgang kann nicht sofort erledigt werden. Entweder muss etwas Aufwändiges berechnet werden oder es werden Daten vom Server abgerufen. Dennoch möchten wir sofort etwas zurückgeben lassen, um damit arbeiten zu können. Wir haben dabei für eine zeitlang noch nicht das echte Ergebnis ist und wissen auch nicht, wann wir das echte Ergebnis geliefert bekommen. Einen Service, der so etwas ermöglicht, nennen wir Promise. Statt dem echten Ergebnis bekommen wir zuerst ein Objekt auf dem wir Methoden aufrufen können. Wenn wir das Ergebnis erhalten haben, werden diese Methoden direkt ausgeführt. Bis dahin liegen sie in einer Warteschlange. Dies ist ein sehr nützliches Pattern, wenn oft Daten ausgetauscht werden.

Formaler ausgedrückt:

* Promises bieten ein einheitliches Interface für asynchrone Funktionsaufrufe
* Promises können das Gesamtergebnis von mehreren asychronen Funktionsaufrufen liefern

Um Daten asynchron zu verarbeiten, können wir auch Callbacks einsetzen. Deshalb gehen wir an dieser Stelle auf deren Nachteile ein.

### Nachteile von klassisches Callbacks

Asynchrone Funktionsaufrufe hat man klassisch in Form von Callbacks vorliegen. Als Beispiel nehmen wir einen Funktionsaufruf per AJAX in jQuery:

~~~javascript
$.get('/tasks', { success: onSuccess, failure: onFailure, always: onAlways });
~~~

Wo liegt der Nachteil an dieser Art der asynchronen Kommunikation?

* Ganz verschiedene Dinge werden mit unterschiedlichen Aufgaben werden im gleichen Codesegement aufgerufen. Es wären z.B. Aufrufe von Animationen, Einfügen von neuen DOM-Elementen oder Blockieren von Form-Elementen möglich.
* Ohne Trigger oder spezielle Vorkehrungen wäre die Erweiterung des Callbacks nicht möglich. Diese Tatsache ist immer wieder für Entwickler von Plugins ärgerlich.
* Das Zusammenspiel mit mehreren Callbacks gestaltet sich schwierig. Eine Verschachtelung erzeugt eine *Pyramid of Doom* (siehe Beispiel). Ein gleichzeichtigtes Abschicken von mehreren Callbacks, bei denen das Ergebnis zusammengefügt wird, erfordert im Verhältnis enormen Aufwand.

~~~javascript
// Pyramid of Doom
aufruf1(function(ergebnis1) {
  aufruf2(function(ergebnis2) {
    aufruf3(function(ergebnis3) { // ...
    });
  });
});
~~~

Natürlich könnte man alles über Trigger steuern. Das heißt für jeden Callback im Erfolgs- und Fehlerfall müsste man einen Trigger schreiben und eine sinnvolle Benamung dafür suchen. Promises sind dagegen eine Methode für die Bequemlichkeit. Sie können verkettet statt geschachtelt werden und das Ergebnis mehrerer Promises kann sehr einfach zusammengefügt werden.

### Der Aufbau von Promises

Ein Promise besteht auf zwei Teilen - der Defer-Funktion und dem Promise selber.

![Promises1](figures/promises.png)

Die Defer-Funktion steuert den Status (Erfolg/Fehler). Das Promise, was von der Defer-Funktion zurückgegeben wird, reagiert auf den Status.

![Promises2](figures/promises2.png)


>> TODO

Nehmen wir als Beispiel ein kleines Würfelspiel. Wer eine 6 würfelt, gewinnt. Gewürfelt wir mit zwei Sekunden Verzögerung.

~~~javascript
var wuerfel = $q.defer();
setTimeout(function() {
  ergebnis = Random...
  if (ergebnis == 6) {
    wuerfel.resolve(ergebnis);
  } else {
    wuerfel.reject(ergebnis);
  }
}, 2000);
promise = wuerfel.promise

promise.then(function(zahl) {
  alert('Erfolg: Du hast eine ' + zahl + ' gewürfelt!');
}, function(zahl) {
  alert('Fehler: Eine ' + zahl + ' reicht leider nicht');
});
~~~


[Beispiel öffnen](http://angularjs.de/code/promises/index.html)


<<(code/promises/index.html)

<<(code/promises/application.js)

### Dynamische Anzahl an asynchronen Aufrufen mit Promises
Stellen wir uns vor, wir haben eine App in der wir ToDos verwalten. Wir haben vom Backend ein Array mit den eindeutigen Schlüsseln für jedes Todo erhalten.
Nun müssen wir durch die Schlüssel iterieren und für jeden Schlüssel ein Ajax-Aufruf durchführen, um die Daten für ein ToDo zu erhalten.

Für unser Beispiel definieren wir uns eine ToDo-Klasse:

<<(code/promises/multiple-promises/Todo.js)

Diese Klasse soll ein ToDo repräsentieren. Es hat eine ID, einen Titel ("Müll rausbringen") und einen Indikator der zeigt, ob das ToDo schon erledigt ist.

Als nächstes definieren wir eine Methode, um die Daten von genau einem ToDo abzurufen:

<<(code/promises/multiple-promises/getSingle.js)

Die Methode erhält eines unserer ToDo Objekte, in der die ID definiert sein muss. Dann ruft es über HTTP und einem Ajax-Aufruf eine URL ab, die uns die Daten für das ToDo liefern soll.
Sobald der Aufruf erfolgreich zurückgekommen ist, füllen wir die Daten aus dem Ergebnis in unser Objekt und übergeben es dem `Promise` mit einem `resolve`.

Nun haben wir die Möglichkeit genau ein ToDo abzurufen. Als nächstes nutzen wir diese Methode, um eine beliebige Anzahl von ToDos in einem Array zu laden.

<<(code/promises/multiple-promises/getMultiple.js)

In dieser Methode speichern wir uns alle in der Schleife erzeugten Promises in ein Array und übergeben der `$q.all()`-Method diese Promises. Die Method kümmert sich dann darum, dass alle Promises erfolgreich ein `resolve` aufgerufen haben und ruft dann sein Erfolgs-/Fehlercallback auf.
Dort rufen wir dann `resolve()` auf, wenn alles erfolgreich geladen werden konnte oder `reject()` wenn eines der Promises ein Fehler meldet.

So ist es uns möglich beliebige Mengen an ToDos zu übergeben und abzurufen. Verwenden kann man die Methode `getAllToDos`, wie eine Methode mit einem `Promise` als Rückgabe.
~~~ javascript
var todo1 = new ToDo(
    {
        "id": "00001"
    }
),
    todo2 = new ToDo(
    {
        "id":"00002"
    }
);
var todos = [todo1, todo2]; // Beliebig viele

getAllTodos(todos).then(function(arrObjTodos){
    $scope.todos = todos;  //Alle Todos wurden erfolgreich geladen
});
~~~

ToDos deklarieren, in das Array einreihen, die Methode `getAllTodos` aufrufen und das erstellte Array übergeben. In das `then` Attribut den gewünschten Callback übergeben, der als Ergebnis das Array mit den fertig geladenen ToDos liefert.


### Verketten von Promises (Chaining)
Promises sollen nun eingesetzt werden, um das Anti-Pattern _Pyramid of Doom_ oder auch _Callback Hell_ zu vermeiden. Doch wie können wir das durch Promises erreichen, wenn nun mehrere asynchrone Aufrufe sequenziell hineinander ausgeführt werden sollen.

Stellen wir uns vor, wir haben zwei asynchrone Methodenaufrufe und möchten nach dessen Fertigstellung eine Logik anstoßen (zum Beispiel die Ladeanimation verstecken).

So ___könnten___ wir das erreichen:

~~~ javascript
showLoadingAnimation();

firstAsyncCall().then(function(){
   secondAsyncCall().then(function(){
        thirdAsyncCall().then(function(){
            hideLoadingAnimation();
        });
   });
});
~~~

Genau hier setzt die Promise-Strategie auf und gibt uns die Möglichkeit folgenden Syntaxzucker zu verwenden:

~~~ javascript
firstAsyncCall()
    .then(secondAsyncCall)
    .then(thirdAsyncCall)
    .then(function(){
        hideLoadingAnimation();
     }););
~~~

Diese Vorgehensweise nennt man __Chaining__ und soll genau das Anti-Pattern vermeiden.
Doch was passiert genau in diesen Zeilen?
Wir rufen `firstAsyncCall` auf und übergeben dem zurückgelieferten Promise einen Callback.
Dieser Callback ist direkt unsere nächste Methode und wird aufgerufen, wenn der erste Methodenaufruf fertig ist.
Der übergebene Callback gibt wiederrum ein Promise zurück, in das wir unser nächsten Callback übergeben.
Dieser Vorgang kann beliebig wiederholt werden.
> Hinweis: Hier wir der Prototyp der Methode übergeben, also ohne die Methodenklammern `()`.

#### Chaining mit Parametern
Doch meistens sollen solche asynchronen Aufrufe ein Ergebnis zurückliefern bzw. als Parameter in das `resolve` übergeben.
Dieses Ergebnis landet dann im `then` Callback als Parameter.

Unsere Ausgangssituation: Wir haben wieder drei asynchrone Methodenaufrufe, die einen Parameter erwarten und einen Parameter zurückgeben.

~~~ javascript
function incrValueAsync(someValue) {
    var deferred = $q.defer();

    $timeout(function(){
        someValue++
        deferred.resolve(someValue);
    },3000);

    return deferred.promise;
}
~~~

Ich werde für dieses Beispiel eine Methode drei Mal verwenden. Sie verzögert die Rückgabe, inkrementiert den übergeben Wert und liefert das Ergebnis zurück.

~~~ javascript
incrValueAsync(0)   //0++
.then(incrValueAsync) //1++
.then(incrValueAsync)  // 2++
.then(incrValueAsync)  //3++
.then(function(value){
   console.log(value);  // 4
});
~~~

In der Syntax hat sich nicht viel zum vorherigen Beispiel geändert. Doch wird hier ein Parameter durch alle Methodenaufrufe durchgezogen und verarbeitet.
Wie angesprochen, liefert `resolve` alle übergeben Parameter in den Callback. In unserem Beispiel ist der Callback die Methode selber, die den Parameter übergeben bekommt.
Diese praktische Technik kann beliebig aneinander gekettet werden.